import numpy as np
from astropy.io import fits
from sophi_hrt_pipe.utils import *
from sophi_hrt_pipe.processes import data_hdr_kw
import os
import time
import subprocess
import datetime
import milos as pym

def create_output_filenames(filename, DID, version = '01',gzip = False):
    """Creating the L2 output filenames from the input file, which is assumed to be L1

    Parameters
    ----------
    filename : str
        The input filename (L1 assumed)
    DID : str
        The Dataset ID (DID) of the input file
    version : str, optional
        The version of the output file, by default '01'
    gzip : bool, optional
        Whether the output file is gzipped, by default False

    Returns
    -------
    stokes_file : str
        The output filename for the Stokes parameters
    icnt_file : str
        The output filename for the continuum intensity
    bmag_file : str
        The output filename for the magnetic field magnitude
    bazi_file : str
        The output filename for the magnetic field azimuth
    binc_file : str
        The output filename for the magnetic field inclination
    blos_file : str
        The output filename for the magnetic field line-of-sight component
    vlos_file : str
        The output filename for the line-of-sight velocity
    """
    file_start = 'solo_L2_phi-hrt-ilam_'
    fmt = "%Y%m%dT%H%M%S"
    
    try:
        temp = time.strftime(fmt,time.strptime(fits.getheader(filename)['DATE-BEG'],'%Y-%m-%dT%H:%M:%S.%f'))
    except Exception:
        temp = 'YYYYmmddTHHMMSS'
        print(f"The input file: {filename} does not contain DATE-BEG keyword: using {temp}")
    
    versioned = file_start + temp + '_V' + version + '_' + DID + '.fits'
    if gzip:
        versioned = versioned + '.gz'
    stokes_file = versioned.replace('ilam', 'stokes')
    icnt_file = versioned.replace('ilam', 'icnt')
    bmag_file = versioned.replace('ilam', 'bmag')
    bazi_file = versioned.replace('ilam', 'bazi')
    binc_file = versioned.replace('ilam', 'binc')
    blos_file = versioned.replace('ilam', 'blos')
    vlos_file = versioned.replace('ilam', 'vlos')
    chi2_file = versioned.replace('ilam', 'chi2')
    fullmodel_file = versioned.replace('ilam', 'FullModel')
    
    return stokes_file, icnt_file, bmag_file, bazi_file, binc_file, blos_file, vlos_file, chi2_file,fullmodel_file


def write_output_inversion(rte_data_products, file_path, scan, hdr_scan, out_dir, out_rte_filename, vers):
    """Write out the L2 files (excluding the Stokes parameters)
    
    Parameters
    ----------
    rte_data_products : np.ndarray
        The RTE data products generated by C-MILOS
    file_path : str
        The input filename (L1 assumed) of the science data
    scan : int
        The scan number
    hdr_scan : astropy.io.fits.header.Header
        The header of the science data
    out_dir : str
        The output directory
    out_rte_filename : str or list
        The output filename(s) for the RTE data products, if None, the output filename will be generated with `create_output_filenames`
    vers : str
        The version of the output file

    Returns
    -------
    None
    """
    if out_rte_filename is None:
        filename_root = str(file_path.split('.fits')[0][-10:])
        if ".gz" in file_path:
            gzip = True
        else:
            gzip = False
        _, icnt_file, bmag_file, bazi_file, binc_file, blos_file, vlos_file, chi2_file, fullmodel_file = create_output_filenames(file_path, filename_root, version = vers, gzip = gzip)

    else:
        if isinstance(out_rte_filename, list):
            filename_root = out_rte_filename[scan]

        elif isinstance(out_rte_filename, str):
            filename_root = out_rte_filename

        else:
            filename_root = str(file_path.split('.fits')[0][-10:])
            print(f"out_rte_filename neither string nor list, reverting to default: {filename_root}")

        blos_file, icnt_file, bmag_file, bazi_file, binc_file, vlos_file, chi2_file, fullmodel_file = 'blos_' + filename_root, 'icnt_' + filename_root, 'bmag_' + filename_root, 'bazi_' + filename_root, 'binc_' + filename_root, 'vlos_' + filename_root, 'chi2_' + filename_root, 'FullModel_' + filename_root

    ntime = datetime.datetime.now()
    hdr_scan['DATE'] = ntime.strftime("%Y-%m-%dT%H:%M:%S")

    # version_k = hdr_scan['VERS_SW']
    # if '.fits' in hdr_scan['CAL_DARK']:
    #     dark_f_k = 'True'
    # else:
    #     dark_f_k = 'False'
    # if '.fits' in hdr_scan['CAL_FLAT']:
    #     flat_f_k = 'True'
    # else:
    #     flat_f_k = 'False'
    # clean_f_k = hdr_scan['CAL_USH']
    # if hdr_scan['CAL_CRT1'] > 0:
    #     ItoQUV_k ='True'
    # else:
    #     ItoQUV_k = 'False'
    rte_sw_k = hdr_scan['RTE_SW']
    rte_mod_k = hdr_scan['RTE_MOD']

    # with fits.open(file_path) as hdu_list:
    #     hdu_list[0].header = hdr_scan
    #     hdu_list[0].data = rte_data_products.astype(np.float32)
    #     hdu_list.writeto(out_dir+filename_root+'_rte_data_products.fits.gz', overwrite=True)
	
    #blos
    print(blos_file)
    im = rte_data_products[2,:,:]*np.cos(rte_data_products[3,:,:]*np.pi/180.)
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = blos_file
        # hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['HISTORY'] = f"RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'BLOS'
        hdr_scan['BUNIT'] = 'Gauss'
        hdr_scan['DATAMIN'] = int(np.min(im))
        hdr_scan['DATAMAX'] = int(np.max(im))
        hdr_scan = data_hdr_kw(hdr_scan, im)

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = im.astype(np.float32)
        hdu_list.writeto(out_dir+blos_file, overwrite=True)

    #bazi
    print(bazi_file)
    im = rte_data_products[4,:,:]
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = bazi_file
        # hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'BAZI'
        hdr_scan['BUNIT'] = 'Degrees'
        hdr_scan['DATAMIN'] = int(0)
        hdr_scan['DATAMAX'] = int(180)
        hdr_scan = data_hdr_kw(hdr_scan, im)

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = im.astype(np.float32)
        hdu_list.writeto(out_dir+bazi_file, overwrite=True)

    #binc
    print(binc_file)
    im = rte_data_products[3,:,:]
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = binc_file
        # hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'BINC'
        hdr_scan['BUNIT'] = 'Degrees'
        hdr_scan['DATAMIN'] = int(0)
        hdr_scan['DATAMAX'] = int(180)
        hdr_scan = data_hdr_kw(hdr_scan, im)

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = im.astype(np.float32)
        hdu_list.writeto(out_dir+binc_file, overwrite=True)

    #bmag
    print(bmag_file)
    im = rte_data_products[2,:,:]
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = bmag_file
        # hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'BMAG'
        hdr_scan['BUNIT'] = 'Gauss'
        hdr_scan['DATAMIN'] = int(0)
        hdr_scan['DATAMAX'] = round(np.max(im),3)
        hdr_scan = data_hdr_kw(hdr_scan, im)

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = im.astype(np.float32)
        hdu_list.writeto(out_dir+bmag_file, overwrite=True)

    #vlos
    print(vlos_file)
    im = rte_data_products[8,:,:]
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = vlos_file
        # hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'VLOS'
        hdr_scan['BUNIT'] = 'km/s'
        hdr_scan['DATAMIN'] = round(np.min(im),6)
        hdr_scan['DATAMAX'] = round(np.max(im),6)
        hdr_scan = data_hdr_kw(hdr_scan, im)

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = im.astype(np.float32)
        hdu_list.writeto(out_dir+vlos_file, overwrite=True)
    
    #chi2
    print(chi2_file)
    im = rte_data_products[11,:,:]
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = chi2_file
        # hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'CHI2'
        hdr_scan['BUNIT'] = ' '
        hdr_scan['DATAMIN'] = round(np.min(im),6)
        hdr_scan['DATAMAX'] = round(np.max(im),6)
        hdr_scan = data_hdr_kw(hdr_scan, im)

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = im.astype(np.float32)
        hdu_list.writeto(out_dir+chi2_file, overwrite=True)

    #Icnt
    print(icnt_file)
    im = rte_data_products[9,:,:] + rte_data_products[10,:,:]
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = icnt_file
        # hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = 'ICNT'
        hdr_scan['BUNIT'] = 'Normalised Intensity'
        hdr_scan['DATAMIN'] = 0
        hdr_scan['DATAMAX'] = round(np.max(im),6)
        hdr_scan = data_hdr_kw(hdr_scan, im)

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = im.astype(np.float32)
        hdu_list.writeto(out_dir+icnt_file, overwrite=True)

    #FullModel
    print(fullmodel_file)
    with fits.open(file_path) as hdu_list:
        hdr_scan['FILENAME'] = fullmodel_file
        # hdr_scan['HISTORY'] = f"Vers: {version_k}. Dark: {dark_f_k}. Flat : {flat_f_k}, Unsharp: {clean_f_k}. I->QUV ctalk: {ItoQUV_k}. RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['HISTORY'] = f"RTE: {rte_sw_k}. RTEmode: {rte_mod_k}."
        hdr_scan['LEVEL'] = 'L2'
        hdr_scan['BTYPE'] = ''
        hdr_scan['BUNIT'] = ''
        hdr_scan['DATAMIN'] = int(np.min(rte_data_products[2:]))
        hdr_scan['DATAMAX'] = int(np.max(rte_data_products[2:]))
        hdr_scan = data_hdr_kw(hdr_scan, rte_data_products[2:])

        hdu_list[0].header = hdr_scan
        hdu_list[0].data = rte_data_products.astype(np.float32)
        hdu_list.writeto(out_dir+fullmodel_file, overwrite=True)


def generate_l2(data_f, hdr_arr, wve_axis_arr, cpos_arr, data, mask, imgdirx_flipped, out_rte_filename, out_dir, cavity_f = None, rows = slice(0,2048), cols = slice(0,2048), vers = '01', rte = "CE+RTE+PSF", pymilos = True, options = [], weight=np.asarray([1.,4.,5.4,4.1]), initial_model=np.asarray([400,30,120,1,0.05,1.5,.01,.22,.85]), parallel = False, num_workers = 20):
    """Pre-process each scan and call `run_pymilos` for each scan in the data set.
    
    Parameters
    ----------
    data_f : list
        List of file paths to the data files.
    hdr_arr : list
        List of header information for each scan.
    wve_axis_arr : list or ndarray
        List of wavelength axis for each scan.
    cpos_arr : list
        List of the continuum position for each scan.
    data : ndarray
        Data array.
    RTE_code : str
        Code used to run the RTE inversion. 'cmilos' or 'pymilos'
    rte : str
        RTE inversion type. Options are 'RTE', 'CE', 'CE+RTE'. 'RTE' is Radiative Transfer Equation inversion, 'CE' is Classical Estimates, 'CE+RTE' is Classical Estimates as initial for Radiative Transfer Equation inversion.
    mask : ndarray
        Mask array.
    imgdirx_flipped : bool
        If True, the image is flipped in the x-direction.
    out_rte_filename : str
        Name of the output file. For standard generated files, set to None
    out_dir : str
        Path to the output directory.
    cavity_f : str, optional
        Path to the cavity file. If None, no cavity correction is applied. The default is None.
    rows : slice, optional
        Rows to be used in the inversion. The default is slice(0,2048).
    cols : slice, optional
        Columns to be used in the inversion. The default is slice(0,2048).
    weight : ndarray, optional
        Weights for the inversion. The default is np.asarray([1.,4.,5.4,4.1]). See `run_pymilos` for more information.
    initial_model : ndarray, optional
        Initial model for the inversion. The default is np.asarray([400,30,120,1,0.05,1.5,.01,.22,.85]). See `run_pymilos` for more information.

    Returns
    -------
    None.
    """
    data_shape = data.shape # (y,x,p,l,s)

    if pymilos == False:
        CMILOS_LOC = os.path.realpath(__file__)

        # CMILOS_LOC = CMILOS_LOC.split('src/')[0] + 'cmilos/' #-11 as hrt_pipe.py is 11 characters
        CMILOS_LOC = CMILOS_LOC.split('src/')[0] + 'pymilos/' #-11 as hrt_pipe.py is 11 characters

        cmd = os.path.join(CMILOS_LOC, 'milos')
        printc('RTE on. Looking for ', cmd, bcolors.OKGREEN)
        if os.path.isfile(cmd):
            printc('CMILOS executable found', color=bcolors.OKBLUE)
        else:
            printc('Cannot find CMILOS executable', bcolors.FAIL)
            raise FileNotFoundError
        # cmd = fix_path(cmd)  # not needed if os.path.join is used
    else:
        cmd = ''
    
    ref_wavelength = 6173.341 # mA
    
    for scan in range(int(data_shape[-1])):
        printc(f'  ---- >>>>> Data scan number: {scan} .... ',color=bcolors.OKGREEN)
        
        start_time = time.perf_counter()

        file_path = data_f[scan]
        wave_axis = wve_axis_arr[scan]
        hdr_scan = hdr_arr[scan]
        
        if cavity_f is not None:
            printc("  ---- >>>>> Correcting wavelengths for Cavity Maps shifts: .... ",color=bcolors.OKGREEN)
            cavity = cavity_shifts(cavity_f,wave_axis,rows,cols,False)
        else:
            cavity = np.empty([], dtype=float)

        if cpos_arr[scan] == 0:
            shift_w =  wave_axis[3] - ref_wavelength
        elif cpos_arr[scan] == 5:
            shift_w =  wave_axis[2] - ref_wavelength
        wave_axis = wave_axis - shift_w
        
        if data.ndim == 5:
            sdata = data[:,:,:,:,scan]
        elif data.ndim > 5 or data.ndim < 4:
            print("Incorrect dimensions of 'data' array")
            exit()
        elif data.ndim == 4:
            sdata = data       
        
        sdata = np.einsum('yxpl->lpyx',sdata.copy())
        nwave, npol, ny, nx = sdata.shape
        
        # possibility to give two weights and/or initial_model
        # first one for AR, second one for QS
        Nw = 1
        if isinstance(weight,list):
            if len(weight) == 2:
                Nw = 2
        elif isinstance(weight,np.array):
            if weight.shape[0] == 2:
                Nw = 2
        Nim = 1
        if isinstance(initial_model,list):
            if len(initial_model) == 2:
                Nim = 2
        elif isinstance(initial_model,np.array):
            if initial_model.shape[0] == 2:
                Nim = 2
        
        if Nw == 1 and Nim ==1:
            rte_invs = pym.phi_rte(sdata.copy(),
                    wave_axis,
                    rte_mode=rte,
                    temp_dir=out_dir,
                    cmd=cmd,
                    options=options,
                    weight=weight,
                    mask=mask[:,:,scan],
                    initial_model=initial_model,
                    cavity=cavity,
                    parallel=parallel, num_workers=num_workers)
        else:
            if Nw == 1:
                weight = [weight,weight]
            if Nim == 1:
                initial_model = [initial_model,initial_model]
            # make AR mask
            ar_mask = ARmasking(sdata, mask[:,:,scan], cpos=cpos_arr[scan], dilation_iter=5)
            rte_invs0 = pym.phi_rte(sdata.copy(),
                    wave_axis,
                    rte_mode=rte,
                    temp_dir=out_dir,
                    cmd=cmd,
                    options=options,
                    weight=weight[0],
                    mask=~ar_mask,
                    initial_model=initial_model[0],
                    cavity=cavity,
                    parallel=parallel, num_workers=num_workers)

            rte_invs1 = pym.phi_rte(sdata.copy(),
                    wave_axis,
                    rte_mode=rte,
                    temp_dir=out_dir,
                    cmd=cmd,
                    options=options,
                    weight=weight[1],
                    mask=ar_mask,
                    initial_model=initial_model[1],
                    cavity=cavity,
                    parallel=parallel, num_workers=num_workers)

            rte_invs = rte_invs1*ar_mask+rte_invs0*(~ar_mask)
        # rte_invs = run_milos(sdata,wave_axis,RTE_code,rte,cpos_arr[0],
        #                      options=options,cavity_f=cavity_f,
        #                      rows=rows,cols=cols,
        #                      weight=weight,mask=mask,initial_model=initial_model,
        #                      out_dir=out_dir) # (nout, ny, nx)
        # rte_invs = np.moveaxis(rte_invs,-1,0) # already in run_pymilos

        # rte_invs_noth = np.copy(rte_invs)

        """
        From 0 to 11
        Counter (PX Id)
        Iterations
        Strength
        Inclination
        Azimuth
        Eta0 parameter
        Doppler width
        Damping
        Los velocity
        Constant source function
        Slope source function
        Minimum chisqr value
        """

        # noise_in_V =  np.mean(sdata[:,:,3,cpos_arr[0]]) #ellipsis in case data has 4 dimensions
        # low_values_flags = np.max(np.abs(sdata[:,:,3,:]),axis=-1) < noise_in_V  # Where values are low
        
        del sdata

        # rte_invs[2,low_values_flags] = 0
        # rte_invs[3,low_values_flags] = 0
        # rte_invs[4,low_values_flags] = 0

        # rte_data_products = np.zeros((7,rte_invs_noth.shape[1],rte_invs_noth.shape[2]))

        # rte_data_products[0,:,:] = rte_invs_noth[9,:,:] + rte_invs_noth[10,:,:] #continuum
        # rte_data_products[1,:,:] = rte_invs_noth[2,:,:] #b mag strength
        # rte_data_products[2,:,:] = rte_invs_noth[3,:,:] #inclination
        # rte_data_products[3,:,:] = rte_invs_noth[4,:,:] #azimuth
        # rte_data_products[4,:,:] = rte_invs_noth[8,:,:] #vlos
        # rte_data_products[5,:,:] = rte_invs_noth[2,:,:]*np.cos(rte_invs_noth[3,:,:]*np.pi/180.) #blos
        # rte_data_products[6,:,:] = rte_invs_noth[11,:,:] #chisq

        rte_invs *= mask[np.newaxis, :, :, scan] #field stop, set outside to 0

        hdr_scan['RTE_MOD'] = rte
        if pymilos:
            hdr_scan['RTE_SW'] = "pymilos "+pym.__version__
        else:
            hdr_scan['RTE_SW'] = "milos "+pym.__version__
        if not(options):
            hdr_scan['RTE_ITER'] = str(30)
        else:
            hdr_scan['RTE_ITER'] = options[1]
        # if cavity_f is not None:
        #     hdr_scan['CAL_CAVM'] = cavity_f
        hdr_scan.set('RTE_W', str(weight), 'Polarimetric weights used in the RTE code', after='RTE_ITER')
        hdr_scan.set('RTE_INIT', str(initial_model), 'Initial model used in the RTE code', after='RTE_ITER')

        write_output_inversion(rte_invs, file_path, scan, hdr_scan, out_dir, out_rte_filename, vers)
        
        # write_fullmodel(rte_data_products, file_path, scan, hdr_scan, out_dir, out_rte_filename, vers)
            
        printc('--------------------------------------------------------------',bcolors.OKGREEN)
        printc(f"------------- MILOS RTE Run Time: {np.round(time.perf_counter() - start_time,3)} seconds ",bcolors.OKGREEN)
        printc('--------------------------------------------------------------',bcolors.OKGREEN)

    
def run_milos(data,wave_axis,RTE_code,rte,cpos, ref_wavelength=6173.341000, options = [],cavity_f = None, rows = slice(0,2048), cols = slice(0,2048),weight=np.asarray([1.,4.,5.4,4.1]),mask=0,initial_model=np.asarray([400,30,120,1,0.05,1.5,.01,.22,.85]), out_dir = './'):
    """Run RTE inversion using `pymilos`: CMILOS with python wrapper for faster I/O
    Make sure to compile pymilos, see `pymilos` documentation for more details

    Parameters
    ----------
    data : numpy array
        4D array of data with dimensions (y,x,4,6) where 4 is the number of polarizations and 6 is the number of wavelengths
    wave_axis : numpy array or list
        1D array of wavelengths in Angstroms
    rte : str
        RTE inversion type. Options are 'RTE', 'CE', 'CE+RTE', 'RTE' is Radiative Transfer Equation inversion, 'CE' is Classical Estiamtes, 'CE+RTE' is Classical Estimates as initial condition for Radiative Transfer Equation inversion
    cpos : int or slice
        continuum position in the wavelength array
    options : numpy array
        1D array of options for the RTE inversion. Default is np.asarray([6,15,0,0]) where 6 is the number of wavelengths, 15 is the max number of RTE iterations, 0 is the RTE inversion type (0 is RTE, 1 is CE+RTE, 2 is CE), 0 is the number of RTE iterations to run after CE+RTE inversion. (Not sure on last one)
    cavity_f : str
        path to cavity map file
    rows : slice
        slice of rows to invert, DEFAULT is slice(0,2048)
    cols : slice
        slice of columns to invert, DEFAULT is slice(0,2048)
    weight : numpy array
        1D array of weights for the RTE inversion. Default is np.asarray([1.,4.,5.4,4.1]) where 1 is Stokes I, 4 is Stokes Q, 5.4 is Stokes U, 4.1 is Stokes V. Based off noise levels in the respective Stokes parameters
    initial_model : numpy array
        1D array of initial model for the RTE inversion. Default is np.asarray([400,30,120,1,0.05,1.5,.01,.22,.85]) where 400 is the magnetic fields strength, 30 is the inclination, 120 is the azimuth, 1 is etha_0, 0.05 is lambda_doppler, 1.5 is AA, 0.01 is vlos, 0.22 is S_0, 0.85 is S_1

    Returns
    -------
    out : numpy array
        3D array of RTE inversion results with dimensions (y,x,r) where is the 12 RTE inversion outputs
        r from 0 to 11:
            Counter (PX Id)
            Iterations
            Strength
            Inclination
            Azimuth
            Eta0 parameter
            Doppler width
            Damping
            Los velocity
            Constant source function
            Slope source function
            Minimum chisqr value
    """
    import pymilos_old as pym
    print(" ")
    printc('-->>>>>>> RUNNING PYMILOS ',color=bcolors.OKGREEN)
    
    # define RTE code
    if RTE_code == 'cmilos':
        CMILOS_LOC = os.path.realpath(__file__)

        # CMILOS_LOC = CMILOS_LOC.split('src/')[0] + 'cmilos/' #-11 as hrt_pipe.py is 11 characters
        CMILOS_LOC = CMILOS_LOC.split('src/')[0] + 'pymilos/' #-11 as hrt_pipe.py is 11 characters

        cmd = os.path.join(CMILOS_LOC, 'milos')
        printc('RTE on. Looking for ', cmd, bcolors.OKGREEN)
        if os.path.isfile(cmd):
            printc('CMILOS executable found', color=bcolors.OKBLUE)
        else:
            printc('Cannot find CMILOS executable', bcolors.FAIL)
            raise FileNotFoundError
        # cmd = fix_path(cmd)  # not needed if os.path.join is used
    elif RTE_code == 'pymilos':
        cmd = ''
    else:
        printc("Error in RTE_code", color=bcolors.WARNING)
    

    if cpos == 0:
        shift_w =  wave_axis[3] - ref_wavelength
    elif cpos == 5:
        shift_w =  wave_axis[2] - ref_wavelength
    wave_axis = wave_axis - shift_w
    
    print('It is assumed the wavelength array is given by the hdr')
    print("Wave axis is: ", (wave_axis - ref_wavelength)*1000.)
    
    # 20230718 HRT pipeline is still using data with this shape: (ny, nx, np, nl)
    # It should be (nl, np, ny, nx)
    if data.ndim == 4:
        sdata = data
        sdata = np.einsum('yxpl->lpyx',sdata.copy())
        nwave, npol, ny, nx = sdata.shape
    elif data.ndim == 2:
        sdata = data
        print("Synthesis Mode Expected")
        nn, nm = sdata.shape
    elif data.ndim == 3:
        sdata = data
        sdata = sdata.reshape((sdata.shape[0],sdata.shape[1]*sdata.shape[2]),order='C')
        print("Synthesis Mode Expected")
        nn, nm = sdata.shape
    else:
        print("Incorrect dimensions of 'data' array")
        exit()
    
    
    options_set = 0
    if not(options):
        print('No input options. Setting for PHI only.')
        options = np.zeros((9))
        options[0] = len(wave_axis) #NLAMBDA wave axis dimension
        options[1] = 30 #MAX_ITER max number of iterations
        options[2] = 1 #CLASSICAL_ESTIMATES [0,1,2] 0=RTE, 1= CE+RTE, 2= CE
        options[3] = 0 #RFS [0,1,2] 0.-> Inversion, 1-> synthesis 2-> RFS
        options[4] = 0 #FWHM = atof(argv[5]);
        options[5] = 0 ##DELTA = atof(argv[6]);
        options[6] = 0 #NMUESTRAS_G = atoi(argv[7]);
        # options[7] = 0 # bad pixel check
        # options[8] = 0 # lambda parameter
        
    else:
        options = np.array(options)
        options_set = 1
        assert (options.size == 7) # 7 with pymilos_old


    """
    * In synthesis mode dimensions are ``[m, n]`` where:

        * ``m`` is the model dimension
        * ``n`` is the number of models
    
    --------> NOT WORKING YET

    ###########################################
    ---------> Synthesis starts here
    ###########################################
    """
        
    if rte in {'SYN', 'SYN+PSF','SYN+RFS','SYN+PSF+RFS'}:
        # RTE IN SYNTHESIS MODE
        # In synthesis mode, the input are not Stokes profiles but a model atmosphere

        #assumes cmd is cmilos
        # if cmd != 'cmilos':
        #     printc('Only for CMILOS yet: ',cmd,color=bcolors.FAIL)
        #     return

        #check if the wavelength axis coincides with the options
        if options[0] != wave_axis.size:
            printc('In synthesis mode, no options are necessary unless PSF.', colors=bcolors.FAIL)
            printc('   Hence options[0] should coincide with wave_axis length ',options[0] ,wave_axis.size,color=bcolors.FAIL)
            return

        #set synthesis mode
        options[3] = 2 if rte in {'SYN+RFS','SYN+PSF+RFS'} else 1

        if rte in {'SYN+PSF','SYN+PSF+RFS'} and not(options_set):
            options[4] = 105 # 0.105 #FWHM = atof(argv[5]);  ·INTEGER NEEDS TO BE CONVERTER TO FLOAT BECOUSE OF / 10000
            options[5] = 70 # 0.070  #DELTA = atof(argv[6]); ·INTEGER NEEDS TO BE CONVERTER TO FLOAT BECOUSE OF / 10000
            options[6] = wave_axis.size  #NMUESTRAS_G = atoi(argv[7]);

        if options[4] > 0:
            printc('PSF in synthesis version activated',color=bcolors.OKBLUE)

        if cmd:  # meaning you will use cmilos
            printc('Using CMILOS ASCII version')
            sdata = sdata.flatten()
            if sdata.size % 9 not in [9, 0]:
                printc('Input data is not multiple of 9. Data length: ',sdata.size,color=bcolors.FAIL)
                return
            nmodels = len(sdata)//9
            #loop over the input
            file_dummy_in = os.path.join(out_dir, 'dummy_in.txt')
            file_dummy_out = os.path.join(out_dir, 'dummy_out.txt')

            filename = file_dummy_in
            with open(filename,"w") as f:
                #loop in wavelength axis
                for waves in wave_axis:
                    f.write('%.10f \n' % (waves) )
                #loop in input model
                iter = 0
                for model in sdata:
                    if not(iter % 9):
                        f.write('%d \n' % (iter // 9) )
                    f.write('%.10f \n' % (model) )
                    iter += 1


            printc('  ---- >>>>> Synthesizing data.... ',color=bcolors.OKGREEN)

            trozo = f" {str(options[0].astype(int))} {str(options[1].astype(int))} {str(options[2].astype(int))} {str(options[3].astype(int))} {str(options[4].astype(int))} {str(options[5].astype(int))} {str(options[6].astype(int))}"

            cmd = cmd + trozo + " " + file_dummy_in + " > " + file_dummy_out
            printc(cmd, color=bcolors.OKGREEN)

            rte_on = subprocess.call(cmd,shell=True)
            printc(rte_on,color=bcolors.OKGREEN)

            printc('  ---- >>>>> Finishing.... ',color=bcolors.OKGREEN)
            printc('  ---- >>>>> Reading results.... ',color=bcolors.OKGREEN)

            res = np.loadtxt(file_dummy_out)
            if nmodels == 1:
                if options[3] == 1:
                    res = np.einsum('ij->ji',res)
                    return res[1:,:]
                if options[3] == 2:
                    res = np.reshape(res,(10,wave_axis.size,5))
                    res = np.einsum('kij->kji',res)
                    return res[:,1:,:]

            if nmodels >  1:
                if options[3] == 1:
                    res = np.reshape(res,(nmodels,wave_axis.size,5))
                    res = np.einsum('kij->kji',res)
                    return res[:,1:,:]
                if options[3] == 2:
                    res = np.reshape(res,(nmodels,10,wave_axis.size,5))
                    res = np.einsum('mkij->mkji',res)
                    return res[:,:,1:,:]
            return
        else:

            printc('Using PMILOS version')
            printc('  ---- >>>>> Synthesizing data.... ',color=bcolors.OKGREEN)
            print('options:',options)
            print('data shape:',sdata.shape)

            res = pym.pmilos(options, sdata, wave_axis, weight, initial_model)
            # n_models,stokes,wave  we would need (wave, pol, y * x)

            #add wavelenth axis for having same behaviour as cmilos

            printc('  ---- >>>>> Finishing.... ',color=bcolors.OKGREEN)

            return res


    """
    ###########################################
    ---------> Synthesis ends here
    ###########################################
    """

    if rte in {'RTE','RTE+PSF'}:
        options[2] = 0
    if rte == 'CE':
        options[2] = 2
    if rte in {'CE+RTE','CE+RTE+PSF'}:
        options[2] = 1
    # I will remove the comments when pymilos with PSF will work!
    if rte in {'CE+RTE+PSF', 'RTE+PSF'}:
        options[4] = 105 # 0.105 #FWHM = atof(argv[5]);
        options[5] = 70 # 0.070  #DELTA = atof(argv[6]);
        options[6] = 6  #NMUESTRAS_G = atoi(argv[7]);

    if cavity_f is not None:
        printc("  ---- >>>>> Correcting wavelengths for Cavity Maps shifts: .... ",color=bcolors.OKGREEN)
        cavity = cavity_shifts(cavity_f,wave_axis,rows,cols,False)
    else:
        cavity = np.empty([], dtype=float)

    start_time = time.perf_counter()
    
    if cmd: # Using cmilos
        # filename = out_dir + 'dummy_in.txt'
        
        # wave_axis = np.broadcast_to(wave_axis, (ny, nx, nwave))
        # wave_axis = np.einsum('ijl->lij', wave_axis)

        # # if cavity is defined, change the wavelength pixel by pixel
        # if cavity.shape:
        #     cavity = np.broadcast_to(cavity, (nwave, ny, nx))
        #     wave_axis = wave_axis - cavity

        # with open(filename,"w") as f:
        #     for i in range(nx):
        #         for j in range(ny):
        #             for k in range(nwave):
        #                 f.write('%e %e %e %e %e \n' % (wave_axis[k,j,i],sdata[k,0,j,i],sdata[k,1,j,i],sdata[k,2,j,i],sdata[k,3,j,i])) #wv, I, Q, U, V

        # printc(f'  ---- >>>>> Inverting data: .... ',color=bcolors.OKGREEN)

        # cmd = fix_path(cmd)

        # trozo = f" {str(int(options[0]))} {str(int(options[1]))} {str(int(options[2]))} {str(int(options[3]))} {str(int(options[4]))} {str(int(options[5]))} {str(int(options[6]))}"
        
        # # print('options: ', options)

        # cmd = cmd + trozo + " " + out_dir+'dummy_in.txt' + " > " + out_dir+'dummy_out.txt'
        # print(cmd)

        out = pym.phi_rte(sdata.copy(),
                 wave_axis,
                 rte,
                 temp_dir=out_dir,
                 cmd=cmd,
                 options=options,
                 weight=weight,
                 mask=mask,
                 initial_model=initial_model,
                 cavity=cavity)
        
        # rte_on = subprocess.call(cmd,shell=True)

        # printc('  ---- >>>>> Reading results.... ',color=bcolors.OKGREEN)
        # del_dummy = subprocess.call(f"rm {out_dir + 'dummy_in.txt'}",shell=True)

        # res = np.loadtxt(out_dir+'dummy_out.txt')
        # out = np.zeros((12,ny*nx)).astype(float)
        # for i in range(ny*nx):
        #     out[:,i] = res[i*12:(i+1)*12]
        # out = out.reshape(12,nx,ny)
        # out = np.einsum('kji->kij', out)
        # _ = subprocess.call(f"rm {out_dir+'dummy_out.txt'}",shell=True)
        
        print('Options:\n',options)
        print('Weights:\n',weight)
        print('Initial model:\n',initial_model)
        printc(f"CMILOS RTE Inversion Run Time: {np.round(time.perf_counter() - start_time,3)} seconds ",bcolors.OKGREEN)

    else:
        
        # printc('Using PMILOS version')
        printc('   input shape in phi_rte: ', sdata.shape)

        # out = pym.phi_rte(sdata.copy(),
        #          wave_axis,
        #          rte,
        #          options=options,
        #          weight=weight,
        #          mask=mask,
        #          initial_model=initial_model,
        #          cavity=cavity)
        
        # OLD PYMILOS
        # Here we flatten the data to be one dimensinal and change the order (size first)
        sdata = sdata.reshape(nwave, npol ,nx*ny)
        printc('   reshaping into: ', data.shape)

        sdata = np.einsum('ijk->kji',sdata)

        if cavity.shape:
            print('   Cavity shape is',cavity.shape)
            cavity = cavity.flatten()
            print('   reshaping cavity (flatten). New cavity shape',cavity.shape)

        printc(f'  ---- >>>>> Inverting data: .... ',color=bcolors.OKGREEN)

        out = pym.pmilos(options,sdata,wave_axis,weight,initial_model,cavity)
        out = np.einsum('ijk->kij', np.reshape(out,(ny,nx,12)))

        printc(f"PYMILOS RTE Inversion Run Time: {np.round(time.perf_counter() - start_time,3)} seconds ",bcolors.OKGREEN)
    
    return out

